import argparse, os

parser = argparse.ArgumentParser()
parser.add_argument("input")
args = parser.parse_args()

def is_vm_file(f):
  return f.endswith(".vm")

def find_all_vm_files(path):
  if os.path.isfile(path):
    if is_vm_file(path):
      return [ path ]
  else:
    out = []
    for root, subdirs, files in os.walk(path):
      for f in files:
        if is_vm_file(f):
          out.append(os.path.join(root, f))
    return out
  
input_files = find_all_vm_files(args.input)
print ("Got files:\n  " + "\n  ".join(input_files))

def strip_comment(line):
  comment = line.find("//")
  if comment == -1:  
    line = line.strip()
  else:
    line = line[:comment].strip()
  return line
  
def parse(input_file):
  out = []
  with open(input_file, 'r') as f:
    for line in f.readlines():
      line = strip_comment(line)
      if line != "":
        out.append(line)
  return out

segments = { "local"    : "LCL",
             "argument" : "ARG",
             "this"     : "THIS",
             "that"     : "THAT",
             "pointer"  : "R3",
             "temp"     : "R5" }

def push_command(segment, index):
  if segment == "constant":
    out = "@" + index + "\nD=A"
  else:
    out = "@" + segments[segment] \
           + "\nD=M\n@" + index + "\nA=A+D\nD=M"
  # assume the value is in D now
  return(out + """\n@SP
A=M
M=D
@SP
M=M+1""")

def pop_command(segment, index):
  return """@SP
AM=M-1 // decr SP, store in SP and follow the decr ptr
D=M    // cache value
@tmp  // store poped value in tmp
M=D
@""" + index + """ // calculate where to store
D=A
@""" + segments[segment] + """
D=M+D
@tmp1 // cache ptr to storage location
M=D
@tmp  // retrieve the popped value
D=M
@tmp1 // retrieve storage loc
A=M   // follow ptr
M=D   // set value"""

# D holds arg0
# A refs M with arg1
# add: M=M+D
# sub: M=M-D
# eq:
# D=M-D
# @IFEQUAL(curjmp)
# D;JEQ
# D=0
# @CONTINUE(curjmp)
# JMP
# (IFEQUAL(curjmp)
# D=1
# (CONTINUE(curjmp))
# @SP
# A=M
# M=D

cur_jmp = [ 0 ]

jumps = { "eq" : "JEQ",
          "gt" : "JGT",
          "lt" : "JLT" }

def comparison(f, cur_jmp=cur_jmp):
  jmp = str(cur_jmp[0])
  cur_jmp[0] += 1
  return """D=M-D
@IFTRUE""" + jmp + """
D;""" + jumps[f] + """
D=0
@CONTINUE""" + jmp + """
D;JMP
(IFTRUE""" + jmp + """)
D=-1
(CONTINUE""" + jmp + """)
@SP
A=M
M=D
@SP
M=M+1"""

simple_functions = { "add" : "+",
                     "sub" : "-",
                     "and" : "&",
                     "or"  : "|"}

def apply2(f):
  out = """@SP
AM=M-1
D=M
AM=A-1
"""
  if f in simple_functions:
    return out + "M=M" + simple_functions[f] + """D
@SP
M=M+1"""
  else:
    return out + comparison(f)

unary_functions = { "neg" : "-",
                    "not" : "!" }

def apply(f):
  return """@SP
A=M
M=""" + unary_functions[f] + "M"

def translate_instruction(instruction):
  out = [ "// " + instruction ]
  instruction = instruction.split()
  if len(instruction) == 3:
    if instruction[0] == "push":
      out.append(push_command(instruction[1], instruction[2]))
    elif instruction[0] == "pop":
      out.append(pop_command(instruction[1], instruction[2]))
    else:
      raise(instruction[0])
  elif len(instruction) == 1:
    f = instruction[0]
    if f in unary_functions:
      out.append(apply(f))
    else:
      out.append(apply2(instruction[0]))
  return("\n".join(out) + "\n")

for input_file in input_files:
  output_file = input_file[:-2] + "asm"
  with open(output_file, 'w') as out:
    print("Working on ", output_file)
    instructions = parse(input_file)
    for instruction in instructions:
      out.write(translate_instruction(instruction))
    print("Done with ", output_file)
    
